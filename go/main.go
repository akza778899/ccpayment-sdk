package main

import (
	"encoding/json"
	"fmt"
	"github.com/bwmarrin/snowflake"
	"github.com/gin-gonic/gin"
	"io/ioutil"
	"net/http"
	"strings"
	"sync"
	"time"
)

var TestCreateOrderUrl = "hhttps://admin.ccpayment.com/ccpayment/v1/pay/CreateTokenTradeOrder"

func main() {

	bill := BillId() // merchant order id
	jsonContent := &JsonContent{
		TokenId:    "e8f64d3d-df5b-411d-897f-c6d8d30206b7",       // from ccpayment support token list
		Chain:      "BSC",                                        //according to user selected
		Amount:     "1",                                          // pay amount
		Contract:   "0x2170ed0880ac9a755fd29b2688956bd959f933f8", //selected token contract
		OutOrderNo: bill,                                         //merchant order id
		FiatName:   "USD",                                        //fiat name just support usd currently
	}
	//content, _ := json.Marshal(jsonContent)
	//timestamps := int64(1672261484)
	//times := strconv.Itoa(int(timestamps))
	//randStr := util.RandStr(5)
	//serviceStr := "ccpayment_id=" + mchid + "&appid=" + arr.Appid + "&json_content=" + string(content) + "&timestamp=" + times + "&noncestr=" + randStr
	serviceStr := "ccpayment_id=CP10001&appid=202301170950281615285414881132544&json_content={\"token_id\":\"e8f64d3d-df5b-411d-897f-c6d8d30206b7\",\"chain\":\"BSC\",\"amount\":\"1\",\"contract\":\"0x2170ed0880ac9a755fd29b2688956bd959f933f8\",\"out_order_no\":\"" + bill + "\",\"fiat_name\":\"USD\"}&timestamp=1672299548&noncestr=ylaDo"
	fmt.Println(serviceStr)
	bt, err := RsaSignWithSha256([]byte(serviceStr), []byte(PrivateKey))
	if err != nil {
		fmt.Println("Sign err:", err)
		return
	}
	req := &SubmitCreateTradeOrderRequest{
		CcpaymentId: "CP10001",
		// it can get from merchant center payment settings(web terminal), only support len(APPID) = 33
		Appid:       "202301170950281615285414881132544",
		Timestamp:   1672299548, // current time unix
		JsonContent: jsonContent,
		//sign data
		Sign: bt,
		// notify url(sync notice merchant change order status) that must be set in the payment settings(web terminal), otherwise program can not work normally
		NotifyUrl: "https://admin.ccpayment.com/merchant/v1/demo/pay/notify",
		Remark:    "",
		//device type only support app currently
		Device: "app",
		//rand str
		Noncestr: "ylaDo",
	}
	bytes, _ := json.Marshal(req)
	response, err := http.Post(TestCreateOrderUrl, "application/json", strings.NewReader(string(bytes)))
	if err != nil {
		fmt.Println("err:", err.Error())
		return
	}
	if response.StatusCode == http.StatusOK {
		body, _ := ioutil.ReadAll(response.Body)
		obj := AutoGenerated{}
		err = json.Unmarshal(body, &obj)
		if err != nil {
			fmt.Println(err)
			return
		}
	}

}

func BillId() string {
	return fmt.Sprintf("%s%d",
		Format(time.Now(), CompactLayout),
		GlobalSnowflakeNode().Generate().Int64())
}

func InitGlobalSnowflakeNode(nodeId int64) (err error) {
	globalSnowflakeNodeSync.Do(func() {
		globalSnowflakeNode, err = snowflake.NewNode(nodeId)
	})

	return err
}

func GlobalSnowflakeNode() *snowflake.Node {
	if globalSnowflakeNode == nil {
		if err := InitGlobalSnowflakeNode(1); err != nil {
			panic(err)
		}
	}

	return globalSnowflakeNode
}

func Format(t time.Time, layout ...string) string {
	if len(layout) != 0 {
		return t.Format(layout[0])
	}
	return t.Format(DefaultLayout)
}

var (
	globalSnowflakeNode     *snowflake.Node
	globalSnowflakeNodeSync sync.Once
)

const CompactLayout = "20060102150405"
const DefaultLayout = "2006-01-02 15:04:05"

type AutoGenerated struct {
	Code int    `json:"code"`
	Msg  string `json:"msg"`
	Data Data   `json:"data"`
}

type Data struct {
	BillID      string `json:"bill_id"`
	RedirectUrl string `json:"redirect_url"`
}

func DemoPayNotifyBack(ctx *gin.Context) {

	encryptParam := struct {
		EncryptData []byte
	}{}
	if err := ctx.BindJSON(&encryptParam); err != nil {
		ctx.String(http.StatusOK, "Failed")
		return
	}
	decryptData, err := RsaDecrypt(encryptParam.EncryptData, []byte(PrivateKey))

	if err != nil {
		ctx.String(http.StatusOK, "Failed")
		return

	}
	data := &EncryptData{}
	err = json.Unmarshal(decryptData, data)
	if err != nil {
		ctx.String(http.StatusOK, "Failed")
		return
	}

	ctx.String(http.StatusOK, "Success")
	return
}

type EncryptData struct {
	MerchantId    int64               `json:"merchant_id"`
	TransactionId string              `json:"transaction_id"`
	Msg           string              `json:"msg"`
	Appid         string              `json:"appid"`
	Timestamp     string              `json:"timestamp"`
	JsonContent   *EncryptJsonContent `json:"json_content"`
}

type EncryptJsonContent struct {
	Chain    string `json:"chain"`
	Amount   string `json:"amount"`
	Contract string `json:"contract"`
	//PayeeAddress string `json:"payee_address"`
	OutOrderNo string `json:"out_order_no"`
	//Symbol     string `json:"symbol"`
	TokenId string `json:"token_id"`
}
